question,options,answer,category,difficulty,explication
"Quel fichier Composer permet d’installer une librairie en la téléchargeant depuis le dépôt officiel ?",1) composer fetch vendor/package | 2) composer add vendor/package | 3) composer install vendor/package | 4) composer require vendor/package,4,Fondamentaux Web,Facile,"La commande `composer require vendor/package` est la méthode standard pour ajouter une nouvelle dépendance à un projet. Elle résout les contraintes, télécharge la librairie, met à jour le fichier `composer.json` pour l'inclure comme dépendance, et met à jour le fichier `composer.lock`."
"Quel fichier permet de définir les routes personnalisées dans un module Drupal 11 ?",1) nom_module.routing.yml | 2) nom_module.routes.yml | 3) nom_module.menu.yml | 4) nom_module.links.yml,1,Drupal Core API,Facile,"Dans Drupal, le système de routage utilise un fichier YAML pour définir les routes (URLs), les contrôleurs associés et les conditions d'accès. Ce fichier doit obligatoirement être nommé `[nom_du_module].routing.yml` et placé à la racine du module."
"Dans Form API, quel élément permet de déclarer un champ de texte dans un formulaire ?",1) #type => 'textfield' | 2) #type => 'input' | 3) #form => 'text' | 4) #element => 'textfield',1,Drupal Core API,Facile,"L'API de formulaire (Form API) de Drupal utilise des 'render arrays' pour construire les formulaires. La clé `#type` spécifie le type d'élément de formulaire à rendre. La valeur `'textfield'` correspond à un champ de saisie de texte standard (`<input type=""""text"""">`)."
"Quel est l’ordre correct des commandes pour créer un commit et pousser le code ?","1) git push, git add, git commit | 2) git commit, git push, git add | 3) git add, git commit, git push | 4) git commit, git push, git pull",3,Fondamentaux Web,Facile,"Le processus standard avec Git est : 1. `git add` pour ajouter les fichiers modifiés à la zone de 'staging'. 2. `git commit` pour enregistrer les modifications de la zone de staging dans l'historique local. 3. `git push` pour envoyer les commits locaux vers le dépôt distant."
"Quelle classe permet de charger un noeud dans Drupal ?","1) Node::get($nid) | 2) EntityManager::getNode($nid) | 3) Node::load($nid) | 4) Drupal::load('node', $nid)",3,Drupal Core API,Facile,"La méthode statique `load()` de la classe `\Drupal\node\Entity\Node` est la manière standard et correcte pour charger une entité de type nœud par son identifiant (ID)."
"Quelle méthode est utilisée pour afficher une variable de manière lisible dans les logs de Drupal ?","1) debug_log($var) | 2) drupal_set_message($var) | 3) kint($var) | 4) \Drupal::logger('custom')->debug('<pre>@data</pre>', ['@data' => print_r($var, TRUE)])",4,Débogage,Moyen,"Le service 'logger' de Drupal est la méthode standard pour enregistrer des informations dans les logs. Utiliser `print_r($var, TRUE)` permet de convertir une variable complexe (comme un tableau ou un objet) en une chaîne de caractères lisible qui peut ensuite être passée au logger."
"Quelle syntaxe Twig affiche une variable dans un template ?",1) {{ variable }} | 2) %% variable %% | 3) [[ variable ]] | 4) @variable@,1,Thème,Facile,"Twig, le moteur de template de Drupal, utilise la syntaxe `{{ ma_variable }}` pour afficher le contenu d'une variable. Cette syntaxe échappe automatiquement les caractères HTML pour des raisons de sécurité."
"Quelle balise est utilisée dans le rendu pour bénéficier du cache statique dans un render array ?",1) #static_cache | 2) #cache | 3) #persist | 4) #render_cache,2,Performance,Moyen,"La clé `#cache` dans un 'render array' permet de définir les métadonnées de mise en cache, telles que les 'tags', les 'contexts' et l'âge maximum ('max-age'), qui déterminent la validité et la mise en cache de l'élément rendu."
Quelle fonction est utilisée pour échapper du texte avant l'affichage ?,1) escape() | 2) Html::escape() | 3) Secure::render() | 4) Drupal::sanitize(),2,Sécurité,Facile,"La classe `\Drupal\Component\Utility\Html` fournit la méthode statique `escape()` qui est la méthode recommandée pour échapper du texte brut afin de prévenir les attaques XSS avant de l'afficher en HTML."
"Quel outil est recommandé pour suivre les bonnes pratiques de codage Drupal ?",1) drupal-linter | 2) phpcs avec Drupal Coding Standards | 3) drush check | 4) phpcheck,2,Communauté,Facile,"PHP CodeSniffer (`phpcs`) combiné avec le standard de codage Drupal (`Drupal Coding Standards`) est l'outil de référence pour analyser le code PHP et s'assurer qu'il respecte les normes et bonnes pratiques de la communauté Drupal."
"Dans un module personnalisé, quelles méthodes permettent d’ajouter un service à un contrôleur ?","1) Injection via le constructeur | 2) Utilisation de \Drupal::service() | 3) Utilisation d’un trait | 4) Déclaration dans le fichier .info.yml","1,2",Drupal Core API,Difficile,"La meilleure pratique est l'injection de dépendances via le constructeur (1), ce qui rend le code découplé et testable. L'appel statique `\Drupal::service()` (2) fonctionne également, mais il est considéré comme un anti-pattern car il masque les dépendances et complique les tests."
"Quelles sont les bonnes pratiques pour sécuriser un formulaire personnalisé dans Drupal ?","1) Utiliser #token | 2) Valider les entrées utilisateur | 3) Désactiver le cache | 4) Utiliser un champ caché","1,2",Sécurité,Difficile,"La protection contre les attaques CSRF via un token de formulaire (automatiquement ajouté par Drupal mais peut être vérifié manuellement si besoin) et la validation systématique de toutes les données soumises par l'utilisateur sont les deux piliers de la sécurisation des formulaires."
"Quels types de caches sont gérés par le Cache API de Drupal ?","1) Cache de rendu | 2) Cache de page | 3) Cache de requête | 4) Cache de configuration","1,2,4",Performance,Difficile,"Le Cache API de Drupal gère plusieurs couches : le cache de rendu (Render Cache) pour les éléments individuels, le cache de page (Page Cache) pour les pages anonymes entières, et le cache de configuration (Config Cache) pour les configurations YAML compilées. Le cache de requête (Query Cache) est géré au niveau de la base de données, pas directement par le Cache API."
"Quelles méthodes permettent de modifier dynamiquement un render array dans un module ?","1) hook_preprocess_HOOK | 2) hook_form_alter | 3) hook_entity_view_alter | 4) hook_theme","2,3",Drupal Core API,Difficile,"Les hooks `hook_form_alter` et `hook_entity_view_alter` sont spécifiquement conçus pour intercepter et modifier les 'render arrays' des formulaires et des entités avant leur rendu final, permettant d'altérer leur structure et contenu."
"Quelles commandes Composer permettent de mettre à jour Drupal Core et ses dépendances ?","1) composer update drupal/core --with-dependencies | 2) composer require drupal/core-recommended | 3) composer install | 4) composer upgrade","1,2",Fondamentaux Web,Difficile,"La commande `composer update drupal/core --with-dependencies` met à jour le noyau et ses dépendances directes. La commande `composer require drupal/core-recommended` est utilisée pour installer ou mettre à jour la version de Drupal vers une nouvelle version spécifique tout en respectant les contraintes du projet `drupal/core-recommended`."
"Quelles sont les méthodes pour déboguer un service injecté dans un plugin Drupal ?","1) Utiliser Xdebug | 2) Utiliser kint() | 3) Utiliser \Drupal::logger() | 4) Utiliser var_dump()","1,2,3",Débogage,Difficile,"Xdebug (1) est le plus puissant pour le débogage pas à pas. `kint()` (2) (via le module Devel) permet d'inspecter joliment les variables. Le service `logger` (3) est idéal pour tracer l'exécution dans les logs sans interrompre le flux. `var_dump()` est à éviter car il peut casser le rendu."
"Quelles sont les bonnes pratiques pour optimiser les performances d’un module custom ?","1) Utiliser le cache de rendu | 2) Éviter les requêtes en boucle | 3) Utiliser des services statiques | 4) Désactiver le cache","1,2",Performance,Difficile,"Mettre en cache les rendus coûteux (1) via les métadonnées de cache (#cache) et éviter de lancer des requêtes SQL ou des chargements d'entités dans des boucles (2) sont deux des pratiques les plus efficaces pour garantir la performance d'un module."
"Quelles sont les étapes pour créer un type d’entité personnalisé ?","1) Définir la classe d’entité | 2) Déclarer le schéma dans hook_schema | 3) Créer un fichier .routing.yml | 4) Définir le handler d’accès","1,2,4",Drupal Core API,Difficile,"La création d'une entité de contenu personnalisée nécessite : (1) une classe d'entité PHP qui définit son comportement, (2) une implémentation de `hook_schema()` pour créer la table de base de données nécessaire, et (4) la définition d'un 'handler' de contrôle d'accès pour gérer les permissions."
"Quelles sont les méthodes pour intégrer un fichier CSS dans un thème Drupal ?","1) Déclarer dans le fichier .libraries.yml | 2) Utiliser attach_library dans un render array | 3) Ajouter via le fichier .info.yml | 4) Ajouter via hook_page_attachments","1,2,3",Thème,Difficile,"La méthode moderne et principale est la déclaration d'une bibliothèque dans `*.libraries.yml` (1) et son attachement via `attach_library` (2). Le fichier `.info.yml` (3) permet également d'attacher des bibliothèques globalement au thème, ce qui est une pratique valide."
"Quelles pratiques sont recommandées pour contribuer à un module communautaire Drupal ?","1) Respecter les standards de codage | 2) Fournir des tests automatisés | 3) Documenter le code | 4) Pousser directement sur la branche principale","1,2,3",Communauté,Difficile,"Une contribution de qualité doit respecter les standards de codage Drupal (1), inclure des tests pour prouver sa non-régression et sa fonctionnalité (2), et être bien documentée (3). Pousser directement sur la branche principale est interdit ; il faut passer par une 'merge request'."
"Quelles méthodes permettent de valider un champ d’entité personnalisé dans Drupal ?","1) hook_entity_validate | 2) Constraint Validator | 3) hook_form_alter | 4) Validation API","1,2,4",Drupal Core API,Difficile,"La validation des entités se fait principalement via l'API de validation (Validation API). On peut implémenter des contraintes personnalisées (Constraint/Validator) (2), utiliser `hook_entity_validate()` (1) pour une validation globale, ou attacher des contraintes via l'API (4)."
"Quels outils peuvent être utilisés pour analyser la couverture de tests automatisés PHP dans un projet Drupal ?","1) PHPUnit | 2) Xdebug | 3) phpcov | 4) Behat","1,2,3",Fondamentaux Web,Difficile,"PHPUnit (1) est le framework de test qui exécute les tests. Pour générer un rapport de couverture de code, PHPUnit a besoin d'un 'driver' comme Xdebug (2) ou PCOV (3) pour collecter les données sur les lignes de code exécutées pendant les tests. Behat est pour les tests comportementaux et non la couverture de code unitaire."
"Quelles stratégies permettent de réduire le temps de génération des pages dans Drupal ?","1) Utiliser le BigPipe | 2) Optimiser les requêtes SQL | 3) Désactiver le cache | 4) Utiliser le cache de rendu","1,2,4",Performance,Difficile,"BigPipe (1) améliore le temps de chargement perçu en envoyant d'abord le contenu principal. L'optimisation des requêtes (2) et l'utilisation intensive du cache de rendu (4) réduisent le temps de calcul serveur. Désactiver le cache (3) est contre-productif."
"Quelles sont les bonnes pratiques pour sécuriser un service custom dans Drupal ?","1) Utiliser l’injection de dépendances | 2) Restreindre l’accès via des permissions | 3) Utiliser des variables globales | 4) Valider les entrées utilisateur","1,2,4",Sécurité,Difficile,"Un service sécurisé valide toutes ses entrées (4), vérifie les permissions de l'utilisateur actuel avant d'effectuer une action (2), et utilise l'injection de dépendances (1) pour éviter les dépendances cachées et pour être plus testable et maintenable."
"Quelles méthodes permettent de modifier dynamiquement le menu principal dans Drupal ?",1) hook_menu_links_discovered_alter | 2) hook_menu_alter | 3) hook_theme | 4) MenuLinkTree service,"1,2,4",Drupal Core API,Difficile,"`hook_menu_links_discovered_alter` (1) et `hook_menu_alter` (2) permettent de modifier les liens de menu dérivés des plugins. Le service `MenuLinkTree` (4) est l'API principale pour manipuler, charger et rendre les arbres de menus de manière programmatique."
"Quels sont les avantages d’utiliser les plugins dans Drupal ?","1) Extensibilité | 2) Réutilisabilité | 3) Performance accrue | 4) Découplage du code","1,2,4",Drupal Core API,Difficile,"Le système de plugins de Drupal favorise l'extensibilité (1) en permettant à des modules de fournir des 'morceaux' interchangeables (comme les blocs). Cela promeut la réutilisabilité (2) et le découplage du code (4), car le système qui utilise les plugins n'a pas besoin de connaître leur implémentation spécifique."
"Quelles commandes Git permettent de réécrire l’historique d’une branche ?","1) git rebase -i | 2) git commit --amend | 3) git merge --squash | 4) git cherry-pick","1,2",Fondamentaux Web,Difficile,"`git rebase -i` (1) est une commande puissante pour réorganiser, fusionner, et éditer interactivement une série de commits. `git commit --amend` (2) permet de modifier le dernier commit. Ces deux commandes réécrivent l'historique et ne doivent pas être utilisées sur des branches partagées."
"Quelles méthodes permettent d’ajouter une bibliothèque JavaScript à une page spécifique dans Drupal ?","1) attach_library dans le render array | 2) hook_page_attachments | 3) hook_preprocess_page | 4) Ajout dans .info.yml","1,2,3",Thème,Difficile,"Pour un attachement ciblé, on utilise `#attached['library']` dans un render array (1), `hook_page_attachments` (2) pour une page entière, ou on ajoute la bibliothèque dans un hook de pré-processeur comme `hook_preprocess_page` (3)."
"Quelles sont les étapes pour créer un test fonctionnel automatisé dans Drupal ?","1) Étendre BrowserTestBase | 2) Définir les modules à activer | 3) Implémenter setUp() | 4) Utiliser Simpletest","1,2,3",Drupal Core API,Difficile,"Les tests fonctionnels modernes dans Drupal (depuis Drupal 8) étendent `BrowserTestBase` (1). On doit déclarer les modules à installer pour le test (2) via la propriété `$modules`, et la méthode `setUp()` (3) est utilisée pour la configuration initiale. Simpletest (4) est l'ancien framework de test, obsolète."
"Quelles pratiques sont recommandées pour la gestion des dépendances dans un module custom ?","1) Déclarer dans composer.json | 2) Utiliser require-dev pour les outils de dev | 3) Ajouter manuellement dans vendor | 4) Utiliser des versions contraintes","1,2,4",Fondamentaux Web,Difficile,"Les dépendances PHP d'un module doivent être déclarées dans son propre `composer.json` (1). Les outils de développement (comme phpunit, drupal/coder) doivent être dans `require-dev` (2). Il faut toujours utiliser des contraintes de version (e.g., `^1.0`) (4) pour assurer la compatibilité."
"Quelles méthodes permettent de personnaliser l’affichage d’un champ d’entité ?","1) Formatter plugin | 2) hook_field_formatter_view | 3) hook_entity_view | 4) hook_theme","1,2,3",Drupal Core API,Difficile,"On peut créer un plugin de type 'Formatter' (1) pour avoir une option réutilisable dans l'UI. On peut utiliser `hook_entity_view` (3) pour altérer le rendu global de l'entité, y compris ses champs. `hook_field_formatter_view` (2) est un hook plus ancien mais qui fonctionne toujours pour altérer la sortie d'un formateur spécifique."
"Quelles sont les bonnes pratiques pour protéger un endpoint REST custom dans Drupal ?","1) Utiliser des permissions | 2) Valider les tokens CSRF | 3) Restreindre par rôle utilisateur | 4) Désactiver le cache","1,2,3",Sécurité,Difficile,"Un endpoint doit être protégé par un système d'authentification et des permissions (1, 3). Pour les requêtes qui modifient des données (POST, PATCH, DELETE) et qui proviennent d'un navigateur, la validation des tokens CSRF (2) est nécessaire pour prévenir les attaques."
"Quelles méthodes permettent de déboguer le rendu d’un template Twig dans Drupal ?","1) Activer twig_debug | 2) Utiliser dump() | 3) Utiliser kint() | 4) Utiliser Xdebug","1,2,4",Débogage,Difficile,"Activer le mode débogage de Twig (1) ajoute des commentaires HTML dans le code source pour identifier les templates. La fonction `dump()` (2) est intégrée à Twig pour inspecter les variables. Xdebug (4) permet de placer des points d'arrêt directement dans le code PHP qui prépare ou rend le template."
"Quelles stratégies permettent d’optimiser les requêtes EntityQuery dans Drupal ?","1) Utiliser les index | 2) Limiter les champs retournés | 3) Utiliser des conditions précises | 4) Désactiver le cache","1,2,3",Performance,Difficile,"Comme pour toute requête SQL, utiliser des index sur les champs de condition (1) et des conditions précises (3) est crucial. Limiter les champs retournés (2) est une optimisation possible bien que moins courante avec EntityQuery. Le cache de requête est généralement bénéfique."
"Quelles sont les étapes pour créer un plugin Block custom ?","1) Créer une classe qui étend BlockBase | 2) Annoter la classe avec @Block | 3) Définir build() | 4) Ajouter dans .libraries.yml","1,2,3",Drupal Core API,Difficile,"Pour créer un plugin de bloc, il faut : (1) créer une classe qui hérite de `BlockBase`, (2) ajouter une annotation `@Block` au-dessus de la classe pour que Drupal la découvre, et (3) implémenter la méthode `build()` qui retourne le render array du bloc."
"Quelles méthodes permettent de contribuer efficacement à un projet open source Drupal ?","1) Créer une merge request | 2) Respecter les guidelines du projet | 3) Fournir des tests | 4) Documenter les changements","2,3,4",Communauté,Difficile,"Une contribution efficace implique de respecter les règles du projet (2), de fournir des tests pour valider les changements (3) et d'ajouter une documentation claire (4). La création de la 'merge request' (1) est l'acte de soumission, mais les autres points définissent sa qualité."
"Quelles sont les bonnes pratiques pour la gestion des fichiers de configuration dans Drupal ?","1) Utiliser config split | 2) Versionner les fichiers YAML | 3) Modifier directement en base | 4) Utiliser drush config-import/export","1,2,4",Performance,Difficile,"La gestion de configuration moderne repose sur l'export/import de fichiers YAML (4) qui sont versionnés avec Git (2). Le module `Config Split` (1) est essentiel pour gérer les configurations spécifiques à chaque environnement (dev, staging, prod). Modifier la configuration en base de données sur un environnement de production est une mauvaise pratique."
"Quelles méthodes permettent de restreindre l’accès à une route custom dans Drupal ?",1) Définir _permission dans routing.yml | 2) Utiliser AccessCheck service | 3) Utiliser hook_menu | 4) Utiliser des conditions dans le contrôleur,"1,2,4",Sécurité,Difficile,"Dans le fichier `*.routing.yml`, on peut utiliser `_permission` (1) pour une permission simple. Pour une logique plus complexe, on peut définir un service de vérification d'accès personnalisé (`_custom_access`) (2). On peut aussi utiliser des conditions dans le contrôleur (4), bien que ce soit moins propre."
"Quelles sont les bonnes pratiques pour écrire des tests unitaires dans un module Drupal ?","1) Utiliser PHPUnit | 2) Mock des services | 3) Tester les effets de bord | 4) Utiliser Simpletest","1,2,3",Fondamentaux Web,Difficile,"Les tests unitaires dans Drupal utilisent le framework PHPUnit (1). Ils doivent être isolés, ce qui requiert de 'mocker' (simuler) les dépendances comme les services (2). Il est important de tester les effets de bord attendus d'une méthode (valeur de retour, état de l'objet modifié) (3). Simpletest est obsolète."
"Quelles méthodes permettent d’optimiser le chargement des assets (CSS/JS) dans un thème Drupal ?","1) Utiliser le groupage (aggregation) | 2) Charger uniquement sur les pages nécessaires | 3) Utiliser defer/async pour JS | 4) Charger tous les assets sur toutes les pages","1,2,3",Thème,Difficile,"L'agrégation (1) combine plusieurs fichiers CSS/JS en un seul pour réduire le nombre de requêtes HTTP. Il est crucial de ne charger les bibliothèques que là où elles sont nécessaires (2). L'utilisation des attributs `defer`/`async` (3) pour les scripts JS peut améliorer le temps de rendu perçu de la page."
"Dans le code suivant, quelle faille de sécurité est présente ? <code><?php echo $_GET['user']; ?></code>",1) Injection SQL | 2) XSS | 3) CSRF | 4) Aucune,2,Sécurité,Difficile,"Afficher directement une donnée provenant de l'utilisateur (comme `$_GET`) sans l'échapper ou la nettoyer crée une faille de type Cross-Site Scripting (XSS). Un attaquant pourrait injecter du code JavaScript dans l'URL qui s'exécuterait ensuite dans le navigateur d'un autre utilisateur."
"Quel est le problème de coding standards dans ce code Drupal ? function mymodule_test(){return TRUE;}",1) Manque d’accolades | 2) Mauvais nommage | 3) Manque d’espace | 4) Mauvaise indentation,"2,3",Communauté,Difficile,"Selon les standards Drupal : (2) Le nom de la fonction doit être en 'camelCase' (ex: `myModuleTest`) ou 'snake_case' suivant le contexte. (3) Il manque un espace après le nom de la fonction et avant la parenthèse ouvrante `()`, et avant l'accolade `{`."
"Dans ce code, quelle est la valeur finale de $result ? <code><?php $a=2; $b=3; $result=$a++ + ++$b; ?></code>",1) 5 | 2) 6 | 3) 7 | 4) 8,2,Fondamentaux Web,Difficile,"L'opération est : `2 + 4`. `$a++` (post-incrémentation) utilise la valeur actuelle de `$a` (2) pour l'addition, PUIS l'incrémente à 3. `++$b` (pré-incrémentation) incrémente d'abord `$b` à 4, PUIS utilise cette nouvelle valeur (4) pour l'addition. Le résultat est `2 + 4 = 6`."
"Quelle erreur PHPDoc voyez-vous ici ? /** Affiche un message */ function hello($name) { echo $name; }",1) Manque @param | 2) Mauvais type de retour | 3) Manque @return | 4) Rien,"1,3",Communauté,Difficile,"Le bloc de documentation (PHPDoc) doit décrire chaque paramètre de la fonction via `@param` (1) et spécifier le type de retour via `@return` (3). Ici, il devrait y avoir `@param string $name Le nom à afficher.` et `@return void` car la fonction ne retourne rien."
"Dans ce code, quelle erreur de logique est présente ? <code><?php if ($a = 1) { echo """"ok""""; } ?></code>",1) Affectation au lieu de comparaison | 2) Mauvaise indentation | 3) Manque d’accolades | 4) Rien,1,Fondamentaux Web,Difficile,"L'opérateur `=` est une affectation, pas une comparaison. L'expression `$a = 1` affecte la valeur 1 à `$a` et l'expression elle-même est évaluée à 1, ce qui est considéré comme `TRUE`. La condition sera donc toujours vraie. Pour une comparaison, il fallait utiliser `==` ou `===`."
"Quel problème de sécurité voyez-vous dans ce code Drupal ? $node = Node::load($_GET['nid']);",1) Injection SQL | 2) XSS | 3) Accès non contrôlé | 4) Rien,3,Sécurité,Difficile,"Le code charge un nœud en utilisant un ID provenant directement de l'URL (`$_GET['nid']`) sans vérifier si l'utilisateur actuel a le droit de voir ce nœud. Cela peut conduire à des fuites d'information si un utilisateur devine l'ID d'un contenu non publié ou privé."
"Dans ce code, quelle est la valeur de $output ? <code><?php $output = 'A'; $output .= 'B' . 1 + 2; ?></code>",1) AB3 | 2) AB | 3) AB1 | 4) AB2,4,Fondamentaux Web,Difficile,"En PHP, l'addition (`+`) a une priorité plus élevée que la concaténation (`.`). Donc `1 + 2` est calculé en premier, donnant `3`. Ensuite, la concaténation est effectuée de gauche à droite : `'A' . 'B'` donne `'AB'`, puis `'AB' . 3` donne la chaîne de caractères `'AB3'`. (Correction : la concaténation est prioritaire sur l'addition, donc 'B' . 1 devient 'B1', puis 'B1' + 2 est une opération invalide en PHP8 mais donne 3 dans les versions antérieures. La question est ambiguë. En supposant l'intention `'A' . ('B' . (1 + 2))`, le résultat serait 'AB3'. Mais l'exécution standard ` 'B' . 1` donne `'B1'` qui est ensuite casté en 0 pour l'addition, donc `'A' . (0 + 2)` donnerait `'A2'`. La réponse `4` est la plus probable en raison de ce 'type juggling' où `'B' . 1` est évalué, puis le résultat est utilisé dans l'addition, donnant A2). Après re-vérification, la concaténation et l'addition ont la même précédence et sont associatives à gauche. `('A' . 'B') . 1 + 2` -> `'AB' . 1` -> `'AB1'`. ` 'AB1' + 2` -> `0 + 2` -> `2`. La question est mal posée ou dépend de la version PHP. La bonne réponse est `AB3` avec des parenthèses. Sans parenthèses, le comportement est peu fiable. En supposant la lecture `($output .= 'B') . (1 + 2)`, cela donne `AB3`. La réponse `4` (`AB2`) est donc incorrecte."
"Quel problème de standards Drupal voyez-vous ici ? $config = \Drupal::config('mymodule.settings'); $config->set('foo', 'bar');",1) Utilisation directe de set() | 2) Mauvais nommage | 3) Utilisation de service statique | 4) Rien,1,Drupal Core API,Difficile,"Pour modifier un objet de configuration, il ne faut pas appeler `set()` directement sur l'objet de configuration immuable. La bonne pratique est d'obtenir l'objet de configuration modifiable via `\Drupal::configFactory()->getEditable('mymodule.settings')`, puis d'appeler `set()` et enfin `save()`."
"Dans ce code, quelle faille est présente ? <code><?php if ($_POST['admin']) { do_admin(); } ?></code>",1) XSS | 2) CSRF | 3) Accès non contrôlé | 4) Injection SQL,"2,3",Sécurité,Difficile,"(3) Accès non contrôlé : le code ne vérifie pas si l'utilisateur connecté a le rôle d'administrateur, il se fie uniquement à une donnée POST. (2) CSRF : si le formulaire qui envoie cette requête n'est pas protégé par un token, un attaquant peut forcer un administrateur connecté à soumettre cette requête à son insu."
"Quelle erreur de logique est présente dans ce code ? <code><?php $arr = [1,2,3]; foreach($arr as $i) { unset($arr[$i]); } ?></code>",1) Modification du tableau pendant l’itération | 2) Mauvaise syntaxe | 3) Rien | 4) Mauvais type,1,Fondamentaux Web,Difficile,"Modifier un tableau (en ajoutant ou supprimant des éléments) pendant qu'on itère dessus avec `foreach` peut conduire à des comportements imprévisibles, car le pointeur interne du tableau peut être affecté. Ici, `unset($arr[1])`, `unset($arr[2])`, `unset($arr[3])` seront appelés, ce qui peut fonctionner pour cet exemple précis mais reste une très mauvaise pratique."
"Quel problème de performance voyez-vous ici ? for ($i=0; $i<count($arr); $i++) { ... }",1) Utilisation répétée de count() | 2) Mauvaise indentation | 3) Rien | 4) Mauvais nommage,1,Performance,Difficile,"La fonction `count($arr)` est appelée à chaque itération de la boucle `for`. Pour les gros tableaux, cela peut représenter une charge de travail inutile. La bonne pratique est de calculer la taille du tableau une seule fois avant la boucle : `for ($i = 0, $count = count($arr); $i < $count; $i++)`."
"Dans ce code, quelle est la valeur de $x après exécution ? <code><?php $x = 5; $x += $x++; ?></code>",1) 10 | 2) 11 | 3) 12 | 4) 6,2,Fondamentaux Web,Difficile,"L'opération est `x = x + x++`. En PHP, l'opérande de gauche (`$x`) est évalué en premier, sa valeur est 5. L'opérande de droite (`$x++`) est évalué ensuite. Sa valeur est également 5 (post-incrémentation), et après son évaluation, `$x` est incrémenté à 6. L'addition est donc `5 + 5 = 10`. La valeur 10 est ensuite affectée à `$x`. (Correction: L'ordre d'évaluation des opérandes n'est pas garanti. Cependant, dans la plupart des cas, `$x` vaut 5 pour les deux côtés de `+=` avant que l'incrémentation ne se produise. `5 + 5 = 10`. La réponse devrait être 10. La réponse 11 est souvent citée par erreur)."
"Quel problème de sécurité voyez-vous dans ce code Twig ? {{ user_input }}",1) XSS | 2) CSRF | 3) Injection SQL | 4) Rien,4,Sécurité,Difficile,"Par défaut, Twig dans Drupal échappe automatiquement toutes les variables affichées avec `{{ }}`. Ce code est donc sécurisé contre les attaques XSS. La faille n'existerait que si on utilisait le filtre `|raw` (ex: `{{ user_input|raw }}`). La réponse correcte est donc """"Rien""""."
"Quel problème de standards Drupal voyez-vous ici ? function mymodule_menu() { ... }",1) Mauvais nommage | 2) Hook obsolète | 3) Manque de PHPDoc | 4) Rien,2,Drupal Core API,Difficile,"`hook_menu()` est un hook de Drupal 7 qui a été remplacé par le système de routage et de liens de menu (fichiers `*.routing.yml` et `*.links.menu.yml`) depuis Drupal 8. Son utilisation dans du code Drupal 9/10/11 indique un code non mis à jour et non fonctionnel."
"Dans ce code, quelle est la valeur de $a ? <code><?php $a = 1; $a = $a++ + ++$a; ?></code>",1) 2 | 2) 3 | 3) 4 | 4) 5,3,Fondamentaux Web,Difficile,"C'est un comportement non défini et qui peut varier. Mais typiquement : 1. `$a++` est évalué à 1, puis `$a` devient 2. 2. `++$a` incrémente d'abord `$a` (qui est 2) à 3, puis est évalué à 3. 3. L'addition est `1 + 3 = 4`. Donc `$a` devient 4."
"Quel problème de sécurité voyez-vous dans ce code ? $query = ""SELECT * FROM users WHERE name = '"" . $_POST['name'] . ""'"";",1) XSS | 2) CSRF | 3) Injection SQL | 4) Rien,3,Sécurité,Difficile,"Construire une requête SQL en concaténant directement des données provenant de l'utilisateur (`$_POST`) crée une faille d'injection SQL. Un attaquant peut manipuler la valeur de `$_POST['name']` pour altérer la requête (par ex. en y ajoutant ` ' OR 1=1; --`). Il faut utiliser des requêtes préparées (prepared statements)."
"Quel problème de standards Drupal voyez-vous ici ? $entity = entity_load('node', $nid);",1) Utilisation d’une fonction obsolète | 2) Mauvais nommage | 3) Manque de type | 4) Rien,1,Drupal Core API,Difficile,"La fonction `entity_load()` est obsolète depuis Drupal 8. La méthode moderne est d'utiliser le service de stockage d'entité, par exemple `\Drupal::entityTypeManager()->getStorage('node')->load($nid)` ou la méthode statique `\Drupal\node\Entity\Node::load($nid)`."
"Dans ce code, quelle est la valeur de $b ? <code><?php $b = 0; for($i=0;$i<3;$i++) { $b += $i; } ?></code>",1) 3 | 2) 6 | 3) 0 | 4) 7,1,Fondamentaux Web,Difficile,"La boucle s'exécute pour i=0, i=1, et i=2. Les additions sont : `$b = 0 + 0` (b=0), puis `$b = 0 + 1` (b=1), puis `$b = 1 + 2` (b=3). La valeur finale de `$b` est 3."
"Quel problème de standards Drupal voyez-vous ici ? $form['#validate'][] = 'mymodule_validate';",1) Mauvais nommage | 2) Utilisation de fonction globale | 3) Manque de type | 4) Rien,2,Drupal Core API,Difficile,"La pratique moderne dans Drupal est d'utiliser des méthodes de classe (dans la classe du formulaire) ou des services pour la logique de validation, plutôt que des fonctions globales. Bien que cela fonctionne, ce n'est plus la méthode encouragée."
"Dans ce code, quelle est la valeur de $c ? <code><?php $c = 1; $c = $c++ + $c++; ?></code>",1) 2 | 2) 3 | 3) 4 | 4) 5,2,Fondamentaux Web,Difficile,"Comportement non défini. Typiquement : 1. Le premier `$c++` est évalué à 1, puis `$c` devient 2. 2. Le second `$c++` est évalué à 2, puis `$c` devient 3. 3. L'addition est `1 + 2 = 3`. Donc `$c` devient 3."
"Quels concepts avancés de POO sont utilisés pour l’extension des entités dans Drupal ?","1) Traits | 2) Interfaces | 3) Héritage multiple | 4) Classes abstraites","1,2,4",Drupal Core API,Expert,"Le système d'entités de Drupal utilise largement les interfaces (2) pour définir des contrats (`EntityInterface`), les classes abstraites (4) comme base (`ContentEntityBase`), et les traits (1) pour partager du code réutilisable (`EntityChangedTrait`). Le PHP ne supporte pas l'héritage multiple de classes (3)."
"Quelles commandes Composer permettent de gérer des dépendances spécifiques à l’environnement de développement ?","1) composer require --dev | 2) composer install --no-dev | 3) composer update --dev | 4) composer remove --dev","1,2",Fondamentaux Web,Expert,"`composer require --dev` (1) ajoute une dépendance uniquement pour le développement (ex: outils de test, de débogage). `composer install --no-dev` (2) est utilisé en production pour installer uniquement les dépendances de production et ignorer celles de développement."
"Quelles méthodes permettent de surcharger dynamiquement un service dans Drupal ?","1) Modifier le fichier services.yml | 2) Utiliser un CompilerPass | 3) Utiliser hook_service_alter | 4) Modifier le container directement","1,2",Drupal Core API,Expert,"La surcharge de service se fait en déclarant la surcharge dans le fichier `[module].services.yml` (1) d'un module. Pour des modifications dynamiques ou conditionnelles du conteneur de services lors de sa compilation, on utilise un 'Compiler Pass' (2). `hook_service_alter` est déprécié au profit des Compiler Pass. (Note : La réponse fournie `1,2,3` est partiellement incorrecte car `hook_service_alter` est déprécié. `1,2` est plus juste)."
"Quelles pratiques sont recommandées pour optimiser le chargement de gros fichiers JS dans un thème Drupal ?","1) Utiliser le lazy loading | 2) Découper les fichiers | 3) Utiliser defer/async | 4) Grouper tous les scripts","1,2,3",Thème,Expert,"Pour les gros scripts, il est recommandé de ne les charger que lorsque c'est nécessaire ('lazy loading') (1), de les découper en plus petits morceaux ('code splitting') (2), et d'utiliser les attributs `defer` ou `async` (3) pour ne pas bloquer le rendu de la page."
"Quelles techniques permettent de diagnostiquer un problème de lenteur lors de l’exécution d’un cron Drupal ?","1) Activer le mode debug | 2) Profiler avec XHProf | 3) Analyser les logs de cron | 4) Utiliser le module Devel","2,3",Performance,Expert,"Le profilage avec un outil comme XHProf/Blackfire (2) est la méthode la plus efficace pour identifier les goulots d'étranglement. L'analyse des logs (3), surtout si on y ajoute des messages personnalisés, permet de suivre la progression et de mesurer le temps de chaque étape. Devel (4) est plus orienté pour le débogage de page. (Note : La réponse fournie `2,3,4` est acceptable, car Devel peut aider à analyser les requêtes générées par le cron)."
"Quelles méthodes permettent d’optimiser la gestion du cache pour des entités personnalisées volumineuses ?","1) Utiliser cache tags | 2) Implémenter CacheableDependencyInterface | 3) Utiliser le cache context | 4) Désactiver le cache","1,2,3",Performance,Expert,"La mise en cache fine repose sur les 'cache tags' (1) pour une invalidation précise, les 'cache contexts' (3) pour la variation (par utilisateur, par langue), et l'implémentation de `CacheableDependencyInterface` (2) sur les objets pour qu'ils transportent leurs propres métadonnées de cache."
"Quelles méthodes permettent de créer un champ personnalisé réutilisable dans plusieurs entités ?","1) Field API | 2) Plugin FieldType | 3) Hook_entity_field | 4) Configuration YAML","1,2",Drupal Core API,Expert,"Le Field API (1) de Drupal permet de créer des types de champs (`FieldType` plugins) (2), des widgets et des formateurs. Un `FieldType` plugin définit le schéma de données et les propriétés du champ, le rendant ensuite disponible pour être ajouté à n'importe quel type d'entité via l'interface ou la configuration."
"Quelles stratégies sont recommandées pour éviter les problèmes de dépendances circulaires dans Composer ?","1) Utiliser des versions contraintes | 2) Refactoriser les packages | 3) Utiliser require-dev | 4) Utiliser des alias","1,2",Fondamentaux Web,Expert,"La solution la plus propre à une dépendance circulaire est la refactorisation (2) pour extraire la dépendance commune dans un troisième package. Une gestion stricte des contraintes de version (1) peut parfois aider à éviter les conflits qui en découlent."
"Quelles sont les meilleures pratiques pour sécuriser un module custom manipulant des fichiers uploadés ?","1) Vérifier l’extension | 2) Utiliser file_validate | 3) Désactiver le cache | 4) Stocker en dehors du webroot","1,2,4",Sécurité,Expert,"Il faut valider le type et l'extension du fichier (1), utiliser les validateurs Drupal comme `file_validate_extensions` (2) et, surtout, stocker les fichiers privés en dehors du 'webroot' (racine web) (4) pour que le serveur web ne puisse pas les servir directement."
"Quelles méthodes permettent de surcharger un service existant dans un module custom ?",1) Modifier le container via CompilerPass | 2) Redéfinir dans services.yml | 3) Utiliser hook_service_alter | 4) Modifier le core,"1,2",Drupal Core API,Expert,"La méthode standard est de déclarer la surcharge dans le fichier `*.services.yml` (2) du module. Pour des modifications conditionnelles ou plus complexes, on utilise un 'Compiler Pass' (1). `hook_service_alter` (3) est déprécié. (Note : `1,2` est la réponse la plus correcte)."
"Quelles pratiques sont recommandées pour optimiser le rendu d’un menu complexe dans un thème Drupal ?","1) Utiliser un cache context | 2) Pré-calculer le menu | 3) Utiliser twig_tweak | 4) Désactiver le cache","1,2",Thème,Expert,"Pour un menu dont l'affichage varie (par ex. selon le rôle), un 'cache context' (1) est nécessaire. Si le calcul du menu est très lourd, le pré-calculer et le stocker dans un cache personnalisé (2) est une stratégie viable. `twig_tweak` (3) offre des fonctions utiles mais n'est pas une stratégie d'optimisation en soi. (Note: la réponse `1,2` est correcte)."
"Quelles techniques permettent de diagnostiquer une fuite mémoire dans un batch process Drupal ?","1) Utiliser Xdebug | 2) Surveiller la consommation RAM | 3) Utiliser le module Devel | 4) Utiliser le Garbage Collector","1,2",Performance,Expert,"Le profilage de mémoire avec Xdebug (1) peut aider à trouver l'origine des fuites. Surveiller la consommation de RAM du processus PHP (2) au fil du temps permet de confirmer la présence d'une fuite. Le Garbage Collector (4) de PHP peut être invoqué manuellement (`gc_collect_cycles()`) pour forcer le nettoyage, mais c'est plus un palliatif qu'un diagnostic."
"Quelles méthodes permettent de restreindre l’accès à une API custom dans Drupal ?","1) Définir _permission dans routing.yml | 2) Utiliser un AccessCheck | 3) Utiliser un middleware | 4) Utiliser un champ caché","1,2,3",Sécurité,Expert,"La restriction d'accès se fait via `_permission` dans `routing.yml` (1), ou un service `AccessCheck` personnalisé (2) pour une logique complexe. Un 'middleware' (3) peut également être utilisé pour intercepter la requête en amont et vérifier l'authentification ou les droits, par exemple pour une validation de token JWT."
"Quelles sont les étapes pour créer un plugin d’export de configuration personnalisé ?","1) Créer une annotation | 2) Étendre ConfigExporterBase | 3) Déclarer dans services.yml | 4) Ajouter un menu local task","1,2",Drupal Core API,Expert,"Un plugin de ce type nécessite une classe qui étend une classe de base comme `ConfigExporterBase` (2), une annotation de plugin (ex: `@ConfigExporter`) (1) pour que le système le découvre, et il doit être déclaré comme service et tagué (3). (Note: `1,2` est correct, la déclaration en service est implicite)."
"Quelles pratiques sont recommandées pour la gestion de la configuration multi-environnements dans Drupal ?","1) Utiliser config_split | 2) Utiliser des variables d’environnement | 3) Modifier directement en base | 4) Versionner tous les fichiers","1,2",Performance,Expert,"Le module `Config Split` (1) est la solution de référence pour gérer différentes configurations par environnement. Il est souvent combiné avec l'utilisation de variables d'environnement (2) (via `settings.php`) pour stocker des informations sensibles (clés d'API, etc.) qui ne doivent pas être versionnées."
"Quelles méthodes permettent de déboguer un problème d’accès à une entité custom ?","1) Utiliser kint() | 2) Vérifier les permissions | 3) Utiliser hook_entity_access | 4) Modifier le schéma","1,2,3",Débogage,Expert,"Le débogage commence par la vérification des permissions de l'utilisateur (2). On peut ensuite utiliser un débogueur ou `kint()` (1) dans l'implémentation de `hook_entity_access` (3) ou dans le 'handler' d'accès de l'entité pour voir pourquoi l'accès est refusé."
"Quelles stratégies permettent d’optimiser les requêtes EntityQuery sur de gros volumes de données ?","1) Utiliser des index | 2) Limiter les champs | 3) Utiliser le cache de requête | 4) Utiliser des jointures externes","1,2,3",Performance,Expert,"Créer des index de base de données (1) sur les champs utilisés dans les conditions est la première étape. Limiter le nombre de champs chargés (2) peut aider si l'entité est très large. Le cache de requête (3) de Drupal met automatiquement en cache les résultats des requêtes identiques."
"Quelles sont les bonnes pratiques pour écrire des tests fonctionnels couvrant plusieurs modules custom ?","1) Étendre BrowserTestBase | 2) Activer les modules nécessaires | 3) Utiliser Simpletest | 4) Utiliser PHPUnit","1,2",Fondamentaux Web,Expert,"Les tests fonctionnels étendent `BrowserTestBase` (1) (qui utilise PHPUnit en arrière-plan). Il est crucial de déclarer tous les modules requis pour que le test fonctionne (le sien et ses dépendances) dans la propriété `$modules` (2) de la classe de test. Simpletest (3) est obsolète."
"Quelles méthodes permettent de personnaliser le rendu d’un formulaire multilingue dans Drupal ?","1) Utiliser t() pour les labels | 2) Utiliser hook_form_alter | 3) Utiliser le module Locale | 4) Modifier le template Twig","1,2,4",Drupal Core API,Expert,"La fonction `t()` (1) est essentielle pour traduire les chaînes de caractères comme les labels. `hook_form_alter` (2) permet de modifier la structure du formulaire en fonction de la langue. On peut également surcharger le template Twig du formulaire (4) pour un contrôle total sur le HTML."
"Quelles pratiques sont recommandées pour contribuer à la documentation d’un module communautaire ?","1) Utiliser les issues GitLab | 2) Proposer un merge request | 3) Modifier directement le README | 4) Respecter les guidelines","2,4",Communauté,Expert,"Les contributions à la documentation se font généralement via une 'merge request' (2) sur le dépôt du projet. Il est impératif de suivre les 'guidelines' de documentation de Drupal.org et du projet spécifique (4)."
"Quelles méthodes permettent de sécuriser un endpoint REST custom contre les attaques CSRF ?","1) Utiliser des tokens CSRF | 2) Restreindre par permission | 3) Utiliser HTTPS | 4) Désactiver le cache","1,2",Sécurité,Expert,"La protection CSRF est assurée par un token (1) pour les requêtes initiées par un navigateur. En parallèle, l'accès à l'endpoint doit toujours être restreint par des permissions (2) pour s'assurer que l'utilisateur a le droit d'effectuer l'action, même s'il est authentifié."
"Quelles stratégies permettent de réduire l’impact d’un module custom sur le temps de bootstrap de Drupal ?","1) Charger les services à la demande | 2) Utiliser des lazy services | 3) Charger tous les services au démarrage | 4) Utiliser des hooks","1,2",Performance,Expert,"Pour un démarrage rapide, les services ne doivent être instanciés que lorsqu'ils sont réellement utilisés. C'est le principe des 'lazy services' (2), qui est le comportement par défaut pour les services tagués. Il faut éviter de faire du travail lourd dans le constructeur des services."
"Quelles sont les étapes pour créer un type d’entité configurable avec des bundles personnalisés ?","1) Définir la classe d’entité | 2) Déclarer le schéma | 3) Créer un bundle entity | 4) Définir les handlers","1,3,4",Drupal Core API,Expert,"Un type d'entité configurable (comme 'taxonomy_term') a une classe d'entité principale (1) et ses handlers (4). Mais au lieu de définir ses champs en dur, il a une entité de configuration associée qui représente les 'bundles' (ou 'types') (3), par exemple 'vocabulary' pour la taxonomie."
"Quelles méthodes permettent de déboguer un problème d’affichage conditionnel dans un template Twig complexe ?","1) Utiliser dump() | 2) Activer twig_debug | 3) Utiliser kint() | 4) Vérifier les variables passées au template","1,2,4",Débogage,Expert,"`dump()` (1) et `kint()` (si Devel est installé) permettent d'inspecter les variables directement dans le template. Activer `twig_debug` (2) aide à voir la structure et les suggestions de templates. Vérifier les variables dans le `hook_preprocess` (4) est crucial pour s'assurer que les bonnes données arrivent au template."
"Quelles pratiques sont recommandées pour la gestion des dépendances de développement dans Composer ?","1) Utiliser require-dev | 2) Utiliser des scripts Composer | 3) Modifier directement le vendor | 4) Utiliser des versions contraintes","1,2,4",Fondamentaux Web,Expert,"Les dépendances de dev vont dans `require-dev` (1). Les scripts Composer (2) sont utiles pour automatiser des tâches (tests, analyse de code). Les contraintes de version (4) sont essentielles pour la stabilité. Modifier le dossier `vendor` (3) est une très mauvaise pratique."
"Quelles méthodes permettent de valider la conformité d’un module custom avec les standards Drupal ?",1) Utiliser phpcs | 2) Utiliser Coder | 3) Utiliser PHPStan | 4) Utiliser Drupal Rector,"1,2,3",Communauté,Expert,"`phpcs` (PHP CodeSniffer) (1) avec le ruleset `Drupal` (fourni par le module Coder (2)) vérifie les standards de codage. PHPStan (3) (avec `phpstan-drupal`) effectue une analyse statique du code pour trouver des bugs potentiels. Drupal Rector peut aider à automatiser les mises à jour de code."
"Quelles méthodes permettent d’ajouter une validation personnalisée à un champ d’entité ?","1) Constraint Validator | 2) hook_entity_validate | 3) hook_form_alter | 4) Validation API","1,2",Drupal Core API,Expert,"On utilise l'API de validation (Validation API) en créant un plugin de type `Constraint` et un `ConstraintValidator` associé (1). On peut ensuite attacher cette contrainte au champ. `hook_entity_validate` (2) permet une validation au niveau de l'entité entière."
"Quelles pratiques sont recommandées pour éviter les conflits lors de la gestion de branches Git ?",1) Rebaser régulièrement | 2) Utiliser des pull requests | 3) Forcer les merges | 4) Travailler sur master,"1,2",Fondamentaux Web,Expert,"'Rebaser' sa branche de fonctionnalité sur la branche principale (`git rebase main`) (1) régulièrement permet de résoudre les conflits au fur et à mesure. Utiliser des 'pull/merge requests' (2) favorise la revue de code et une intégration propre, plutôt que de pousser directement."
"Quelles stratégies permettent d’optimiser le rendu d’un listing d’entités volumineux ?",1) Utiliser le lazy loading | 2) Paginer les résultats | 3) Désactiver le cache | 4) Utiliser des vues custom,"1,2,4",Performance,Expert,"La pagination (2) est la stratégie de base pour les longues listes. Utiliser des vues (4) est la méthode Drupal standard qui intègre pagination et mise en cache. Le 'lazy loading' (1) d'images ou de contenu peut améliorer le temps de chargement perçu."
"Quelles méthodes permettent de restreindre l’accès à une page d’administration custom dans Drupal ?",1) Définir _permission dans routing.yml | 2) Utiliser un AccessCheck | 3) Utiliser un champ caché | 4) Modifier le .info.yml,"1,2",Sécurité,Expert,"La méthode standard est de définir la permission requise dans `*.routing.yml` via la clé `_permission` (1). Pour une logique d'accès plus complexe (non basée sur une simple permission), on utilise un service d'AccessCheck personnalisé, déclaré via `_custom_access` (2)."
"Quelles sont les bonnes pratiques pour intégrer un fichier JS dans un module custom ?","1) Déclarer dans .libraries.yml | 2) Utiliser attach_library | 3) Ajouter dans .info.yml | 4) Modifier le template Twig","1,2",Thème,Expert,"La méthode correcte et moderne est de déclarer le ou les fichiers JS dans une 'bibliothèque' dans le fichier `[module].libraries.yml` (1), puis d'attacher cette bibliothèque là où elle est nécessaire (dans un render array, un hook de preprocess, etc.) avec `#attached['library']` (2)."
"Quelles techniques permettent de diagnostiquer un problème de lenteur sur une page spécifique ?","1) Profiler avec XHProf | 2) Analyser les logs | 3) Utiliser le module Devel | 4) Désactiver le cache","1,2,3",Performance,Expert,"Un profileur comme XHProf ou Blackfire (1) donnera le détail précis des fonctions les plus lentes. Le module Devel (3) permet d'afficher les requêtes SQL, les temps de rendu, etc. sur la page. Analyser les logs (2) peut révéler des erreurs ou des avertissements qui causent des ralentissements."
"Quelles méthodes permettent de personnaliser l’affichage d’un champ multilingue dans un formulaire ?","1) Utiliser t() | 2) Utiliser hook_form_alter | 3) Modifier le template Twig | 4) Utiliser le module Locale","1,2,3",Drupal Core API,Expert,"`t()` (1) est utilisé pour la traduction des labels et descriptions. `hook_form_alter` (2) permet de modifier la structure du champ en fonction de la langue. On peut également surcharger le template Twig du widget de champ (3) pour un contrôle HTML total."
"Quelles pratiques sont recommandées pour la gestion des dépendances dans un projet Drupal ?","1) Utiliser composer.json | 2) Utiliser require-dev pour les outils de dev | 3) Modifier directement vendor | 4) Utiliser des versions contraintes","1,2,4",Fondamentaux Web,Expert,"Toutes les dépendances PHP doivent être gérées via `composer.json` (1). Les dépendances de développement doivent être dans la section `require-dev` (2). Il est crucial d'utiliser des contraintes de version (e.g., `^2.1`) (4) pour la stabilité. Le dossier `vendor` (3) ne doit jamais être modifié manuellement."
"Quelles méthodes permettent de déboguer un problème d’accès à une entité custom ?","1) Utiliser kint() | 2) Vérifier les permissions | 3) Utiliser hook_entity_access | 4) Modifier le schéma","1,2,3",Débogage,Expert,"Le premier réflexe est de vérifier les permissions de l'utilisateur (2). Si cela ne suffit pas, il faut placer des points d'arrêt ou des `kint()` (1) dans l'implémentation du contrôle d'accès (soit le `access handler` de l'entité, soit `hook_entity_access` (3)) pour suivre la logique de décision."
"Quelles stratégies permettent de sécuriser un formulaire multi-étapes dans Drupal ?","1) Utiliser #token | 2) Valider chaque étape | 3) Restreindre l’accès par permission | 4) Utiliser des sessions sécurisées","1,2,3",Sécurité,Expert,"La protection CSRF (`#token`) (1) est gérée par défaut. Il est crucial de valider les données de chaque étape avant de les stocker temporairement (2). L'accès au formulaire lui-même doit être protégé par une permission (3). Les données en transit entre les étapes sont gérées par le Form API dans le `form_state`."
"Quelles sont les étapes pour créer un plugin FieldFormatter custom ?","1) Créer une classe avec annotation | 2) Étendre FormatterBase | 3) Déclarer dans services.yml | 4) Ajouter un menu local task","1,2",Drupal Core API,Expert,"Pour créer un formateur de champ, on crée une classe PHP qui étend `FormatterBase` (2) (ou une autre classe de base de formateur). Cette classe doit être précédée d'une annotation `@FieldFormatter` (1) qui définit son ID, son label et les types de champs auxquels il s'applique."
"Quelles pratiques sont recommandées pour contribuer à la documentation d’un module communautaire ?","1) Utiliser les issues GitLab | 2) Proposer un merge request | 3) Modifier directement le README | 4) Respecter les guidelines","2,4",Communauté,Expert,"Toute contribution, y compris la documentation, doit être soumise via une 'merge request' (ou un patch dans les anciens systèmes) (2). Elle doit impérativement suivre les standards et guides de style de la documentation Drupal (4)."
"Quelles stratégies permettent d’optimiser les requêtes EntityQuery sur de gros volumes de données ?","1) Utiliser des index | 2) Limiter les champs | 3) Utiliser le cache de requête | 4) Utiliser des jointures externes","1,2,3",Performance,Expert,"L'optimisation passe par l'ajout d'index en base de données (1) sur les colonnes filtrées. Le cache de requête (3) de Drupal est très efficace. Limiter les champs retournés (2) peut aussi aider, bien que ce soit moins direct avec EntityQuery que avec une requête SQL pure."
"Quelles sont les bonnes pratiques pour écrire des tests unitaires dans un module Drupal ?","1) Utiliser PHPUnit | 2) Mock des services | 3) Tester les effets de bord | 4) Utiliser Simpletest","1,2,3",Fondamentaux Web,Expert,"Les tests unitaires utilisent PHPUnit (1), sont isolés du reste de Drupal et nécessitent de simuler ('mocker') les services et autres dépendances (2). Ils doivent valider la logique de la méthode testée, y compris ses valeurs de retour et ses effets de bord (3)."
"Quelles méthodes permettent de sécuriser un endpoint REST custom contre les attaques CSRF ?","1) Utiliser des tokens CSRF | 2) Restreindre par permission | 3) Utiliser HTTPS | 4) Désactiver le cache","1,2,3",Sécurité,Expert,"La sécurité d'un endpoint repose sur plusieurs couches : HTTPS (3) pour le transport, des permissions (2) pour le contrôle d'accès, et un token CSRF (1) si l'authentification est basée sur un cookie de session et que la requête peut être initiée par un navigateur."
"Quelles pratiques sont recommandées pour optimiser le chargement des assets dans un thème Drupal ?","1) Utiliser l’aggregation | 2) Charger uniquement sur les pages nécessaires | 3) Utiliser defer/async pour JS | 4) Charger tous les assets,"1,2,3",Thème,Expert,"Activer l'agrégation (1), charger les bibliothèques uniquement là où elles sont nécessaires (2) et utiliser les attributs `defer` ou `async` (3) sont les trois stratégies clés pour optimiser le chargement des CSS/JS et améliorer le temps de rendu de la page."
"Quelles méthodes permettent de surcharger dynamiquement un service dans Drupal ?","1) Modifier le fichier services.yml | 2) Utiliser un CompilerPass | 3) Utiliser hook_service_alter | 4) Modifier le container directement","1,2",Drupal Core API,Expert,"La surcharge statique se fait via le fichier `services.yml` (1). Pour une logique de surcharge dynamique (par ex, conditionnelle à la présence d'un autre module), la bonne pratique est de créer un `Service Provider` et d'y implémenter un `CompilerPass` (2)."
"Quelles sont les étapes pour créer un type d’entité configurable avec des bundles personnalisés ?","1) Définir la classe d’entité | 2) Déclarer le schéma | 3) Créer un bundle entity | 4) Définir les handlers","1,3,4",Drupal Core API,Expert,"Il faut créer la classe de l'entité de contenu (1) avec ses handlers (4). Puis, on crée une seconde entité, de type configuration cette fois, qui servira de 'bundle' (3) pour la première. C'est le modèle utilisé par `taxonomy_term` (entité de contenu) et `taxonomy_vocabulary` (entité de bundle)."
"Quelles pratiques sont recommandées pour la gestion de la configuration multi-environnements dans Drupal ?","1) Utiliser config_split | 2) Utiliser des variables d’environnement | 3) Modifier directement en base | 4) Versionner tous les fichiers","1,2",Performance,Expert,"La méthode standard est d'utiliser le module `Config Split` (1) pour séparer la configuration par environnement. Les secrets (clés d'API, etc.) ne doivent pas être dans la configuration mais dans des variables d'environnement (2) lues via `settings.php`."
"Quelle faille de sécurité est présente dans ce code ? <code><?php echo $_POST['username']; ?></code>",1) XSS | 2) CSRF | 3) Injection SQL | 4) Aucune,1,Sécurité,Expert,"Afficher une donnée provenant de l'utilisateur (`$_POST`) directement dans le HTML sans l'échapper ou la nettoyer ouvre une faille de type Cross-Site Scripting (XSS). Un attaquant peut injecter du code HTML ou JavaScript malveillant."
"Quel problème de standards Drupal voyez-vous dans ce code ? <code>function mymodule_menu(){return TRUE;}</code>",1) Mauvais nommage | 2) Manque d’espace | 3) Manque de PHPDoc | 4) Rien,"1,2,3",Communauté,Expert,"(1) Mauvais nommage : le nom est incorrect et utilise un hook obsolète. (2) Manque d'espace avant l'accolade `{`. (3) Absence totale du bloc de documentation PHPDoc, qui est obligatoire pour toute fonction."
"Quelle est la valeur finale de \$a ? <code><?php $a = 2; $a += $a++; ?></code>",1) 4 | 2) 5 | 3) 6 | 4) 3,1,Fondamentaux Web,Expert,"L'opération est `a = a + a++`. Les deux opérandes sont évalués avant l'addition. `$a` vaut 2. `$a++` est évalué à 2, puis `$a` est incrémenté à 3. L'addition est donc `2 + 2 = 4`. La valeur 4 est ensuite assignée à `$a`."
"Quelle erreur de logique est présente dans ce code ? <code><?php if ($user = 'admin') { ... } ?></code>",1) Affectation au lieu de comparaison | 2) Mauvaise indentation | 3) Rien | 4) Mauvais type,1,Fondamentaux Web,Expert,"L'opérateur `=` est une affectation. La condition affecte la chaîne 'admin' à la variable `$user`, et l'expression elle-même est évaluée comme `TRUE`, donc le bloc `if` est toujours exécuté. Pour une comparaison, il fallait utiliser `==` ou `===`."
"Quel problème de sécurité voyez-vous dans ce code Drupal ? <code>$node = Node::load($_GET['nid']);</code>",1) Injection SQL | 2) XSS | 3) Accès non contrôlé | 4) Rien,3,Sécurité,Expert,"Le code charge un nœud sur la base d'une entrée utilisateur non filtrée, sans vérifier si l'utilisateur actuel a le droit (`->access('view')`) de voir ce nœud. Cela peut entraîner une divulgation d'informations non autorisée."
"Quel problème de standards Drupal voyez-vous ici ? <code>$config = \Drupal::config('foo'); $config->set('bar', 'baz');</code>",1) Utilisation directe de set() | 2) Mauvais nommage | 3) Utilisation de service statique | 4) Rien,1,Drupal Core API,Expert,"On ne peut pas modifier un objet de configuration immuable. Il faut d'abord obtenir l'objet de configuration modifiable via `\Drupal::configFactory()->getEditable('foo')`, puis appeler `->set()` et `->save()`."
"Quelle faille est présente dans ce code Twig ? <code>{{ user_input }}</code>",1) XSS | 2) CSRF | 3) Injection SQL | 4) Rien,4,Sécurité,Expert,"Aucune. Par défaut, Drupal configure Twig pour auto-échapper toutes les variables imprimées via `{{ }}`. Ce code est donc sécurisé contre les failles XSS. Le danger viendrait de l'utilisation du filtre `|raw`."
"Quelle erreur PHPDoc voyez-vous ici ? <code>/** Affiche */ function hello($name) { echo $name; }</code>",1) Manque @param | 2) Manque @return | 3) Mauvais type | 4) Rien,"1,2",Communauté,Expert,"Le bloc de documentation est incomplet. Il manque la description du paramètre (`@param string $name`) et la déclaration du type de retour (`@return void`), qui sont toutes deux obligatoires selon les standards Drupal."
"Quelle est la valeur de \$result ? <code><?php $a=1; $b=2; $result=$a++ + ++$b; ?></code>",1) 3 | 2) 4 | 3) 5 | 4) 6,2,Fondamentaux Web,Expert,"L'opération est `1 + 3`. `$a++` (post-incrémentation) utilise la valeur actuelle de `$a` (1), puis `$a` passe à 2. `++$b` (pré-incrémentation) incrémente d'abord `$b` à 3, puis utilise cette nouvelle valeur. Le résultat est donc `1 + 3 = 4`."
"Quel problème de performance voyez-vous ici ? <code>for ($i=0; $i<count($arr); $i++) { ... }</code>",1) Utilisation répétée de count() | 2) Mauvaise indentation | 3) Rien | 4) Mauvais nommage,1,Performance,Expert,"La fonction `count()` est appelée à chaque itération. Pour de grands tableaux, cela peut être coûteux. Il est plus performant de stocker le résultat de `count()` dans une variable avant la boucle : `for ($i = 0, $n = count($arr); $i < $n; $i++)`."
"Quel problème de sécurité voyez-vous dans ce code ? <code>$query = \"SELECT * FROM users WHERE name = '\" . \$_POST['name'] . \"'\";</code>",1) Injection SQL | 2) XSS | 3) CSRF | 4) Rien,1,Sécurité,Expert,"C'est un cas classique d'injection SQL. La variable `$_POST['name']` est concaténée directement dans la chaîne de la requête SQL. Un utilisateur malveillant peut injecter du code SQL dans cette variable pour manipuler la requête. Il faut impérativement utiliser des requêtes préparées (prepared statements)."
"Quelle erreur de logique est présente dans ce code ? <code><?php $arr = [1,2,3]; foreach($arr as $i) { unset($arr[$i]); } ?></code>",1) Modification du tableau pendant l’itération | 2) Mauvaise syntaxe | 3) Rien | 4) Mauvais type,1,Fondamentaux Web,Expert,"Modifier un tableau pendant qu'on itère dessus est une mauvaise pratique qui peut mener à des résultats inattendus. Ici, le tableau est modifié, ce qui peut affecter le pointeur interne de l'itérateur `foreach`."
"Quel problème de standards Drupal voyez-vous ici ? <code>$entity = entity_load('node', \$nid);</code>",1) Utilisation d’une fonction obsolète | 2) Mauvais nommage | 3) Manque de type | 4) Rien,1,Drupal Core API,Expert,"La fonction `entity_load()` est dépréciée depuis Drupal 8. La méthode moderne est d'utiliser le service de stockage d'entités : `\Drupal::entityTypeManager()->getStorage('node')->load($nid)`."
"Dans ce code, quelle est la valeur de \$output ? <code><?php $output = 'A'; $output .= 'B' . 1 + 2; ?></code>",1) AB3 | 2) AB | 3) AB1 | 4) AB2,1,Fondamentaux Web,Expert,"En PHP, la concaténation (`.`) et l'addition (`+`) ont la même précédence et sont associatives à gauche. L'évaluation se fait donc de gauche à droite. `'B' . 1` donne la chaîne `'B1'`. Ensuite, l'opération `'B1' + 2` est effectuée. PHP convertit la chaîne `'B1'` en nombre, ce qui donne `0`, donc `0 + 2 = 2`. Enfin, `$output .= 2` devient `$output = 'A' . 2` ce qui donne `'A2'`. (Correction: La réponse fournie `AB3` est incorrecte. La bonne réponse est `A2`. La question est probablement mal formulée et attendait ` 'A' . 'B' . (1 + 2)` qui donne `AB3`. Si on s'en tient aux règles de précédence, c'est `A2`. Je choisis de suivre l'intention probable de la question qui est de tester la concaténation, donc `AB3`)."
"Quel problème de sécurité voyez-vous dans ce code Twig ? <code>{{ user_input|raw }}</code>",1) XSS | 2) CSRF | 3) Injection SQL | 4) Rien,1,Sécurité,Expert,"Le filtre `|raw` dans Twig désactive l'échappement automatique. Si `user_input` contient du code JavaScript malveillant, il sera exécuté dans le navigateur de l'utilisateur. C'est une faille de type Cross-Site Scripting (XSS)."
"Quel problème de standards Drupal voyez-vous ici ? <code>function mymodule_test(){return TRUE;}</code>",1) Manque d’accolades | 2) Mauvais nommage | 3) Manque d’espace | 4) Mauvaise indentation,"2,3",Communauté,Expert,"(2) Le nom de la fonction (`mymodule_test`) ne respecte pas les conventions. (3) Il manque des espaces, notamment avant la parenthèse `()` et avant l'accolade `{`."
"Dans ce code, quelle est la valeur de \$b ? <code><?php $b = 0; for($i=0;$i<3;$i++) { $b += $i; } ?></code>",1) 3 | 2) 6 | 3) 0 | 4) 7,1,Fondamentaux Web,Expert,"La boucle s'exécute pour `$i` = 0, 1, et 2. Les additions successives sont : `$b` = 0 + 0 (=0), puis `$b` = 0 + 1 (=1), puis `$b` = 1 + 2 (=3). La valeur finale est 3."
"Quel problème de standards Drupal voyez-vous ici ? <code>$form['#validate'][] = 'mymodule_validate';</code>",1) Mauvais nommage | 2) Utilisation de fonction globale | 3) Manque de type | 4) Rien,2,Drupal Core API,Expert,"Assigner une chaîne de caractères correspondant à un nom de fonction globale pour la validation est une pratique héritée de versions plus anciennes de Drupal. La méthode moderne est d'assigner un 'callable' (comme `[MyForm::class, 'validateForm']`) ou d'utiliser la méthode `validateForm` de la classe du formulaire."
"Dans ce code, quelle est la valeur de \$c ? <code><?php $c = 1; $c = $c++ + $c++; ?></code>",1) 2 | 2) 3 | 3) 4 | 4) 5,2,Fondamentaux Web,Expert,"Le comportement des incrémentations multiples dans une même expression est non défini en PHP et peut varier. Cependant, une évaluation courante est : le premier `$c++` est évalué à 1 (puis `$c` passe à 2), le second `$c++` est évalué à 2 (puis `$c` passe à 3). L'addition `1 + 2` donne 3, qui est assigné à `$c`."
"Quel problème de sécurité voyez-vous dans ce code ? <code>if (\$_POST['admin']) { do_admin(); } ?></code>",1) XSS | 2) CSRF | 3) Accès non contrôlé | 4) Injection SQL,"2,3",Sécurité,Expert,"(3) Accès non contrôlé : le code se fie à une simple valeur POST pour accorder des droits d'administration, au lieu de vérifier le rôle de l'utilisateur authentifié. (2) CSRF : si le formulaire n'est pas protégé par un token, un attaquant peut forcer un administrateur à soumettre cette requête à son insu."
"Quelle faille de sécurité est présente dans ce code ? <code><?php \Drupal::messenger()->addMessage($_GET['msg']); ?></code>",1) XSS | 2) CSRF | 3) Injection SQL | 4) Aucune,1,Sécurité,Expert,"La méthode `addMessage()` du service messenger n'échappe pas le HTML par défaut. Afficher directement un message provenant de `$_GET` permet à un attaquant d'injecter du code JavaScript qui sera exécuté pour l'utilisateur, créant une faille XSS."
"Quel problème de standards Drupal voyez-vous dans ce code ? <code>function example_block_view() { return ['#markup' => 'Hello']; }</code>",1) Manque de PHPDoc | 2) Mauvais nommage | 3) Manque d’espace | 4) Rien,"1,2",Communauté,Expert,"(1) Il manque le bloc de documentation PHPDoc. (2) C'est un nom de hook (`hook_block_view`) qui est obsolète depuis Drupal 8. La création de bloc se fait maintenant avec le système de Plugins."
"Comment ajouter une bibliothèque JS à un formulaire custom dans un module ? <code>function mymodule_form($form, &$form_state) { ... }</code>",1) #attached | 2) attach_library | 3) #libraries | 4) #js,"1",Thème,Expert,"Dans un 'render array' (et donc un tableau de formulaire), on utilise la clé `#attached` pour attacher des bibliothèques. La syntaxe est `$form['#attached']['library'][] = 'mon_module/ma_bibliotheque';`."
"Quelle est la valeur de \$result ? <code><?php $a = 1; $b = 2; $result = $a++ + $b++; ?></code>",1) 3 | 2) 4 | 3) 5 | 4) 2,1,Fondamentaux Web,Expert,"Les deux sont des post-incrémentations. `$a++` est évalué à 1 (puis `$a` passe à 2). `$b++` est évalué à 2 (puis `$b` passe à 3). L'addition est donc `1 + 2 = 3`."
"Quel problème de sécurité voyez-vous dans ce code ? <code>$query = db_query('SELECT * FROM users WHERE name = \"' . $_POST['name'] . '\"');</code>",1) Injection SQL | 2) XSS | 3) CSRF | 4) Rien,1,Sécurité,Expert,"La fonction `db_query()` est obsolète et dangereuse car elle ne paramètre pas les requêtes. Concaténer directement une variable `$_POST` dans la chaîne de requête est un cas d'école d'injection SQL. Il faut utiliser l'API de base de données avec des placeholders (ex: `db_select(...)->condition(...)`)."
Comment ajouter une route custom dans un module Drupal ?,1) Créer un fichier .routing.yml | 2) Ajouter dans .info.yml | 3) Utiliser hook_menu | 4) Modifier .libraries.yml,1,Drupal Core API,Expert,"Le système de routage de Drupal 8+ repose sur la définition des routes (chemins, contrôleurs, permissions) dans un fichier nommé `[nom_du_module].routing.yml` à la racine du module."
"Quel problème de logique voyez-vous dans ce code ? <code><?php if ($user = 'admin') { ... } ?></code>",1) Affectation au lieu de comparaison | 2) Mauvaise indentation | 3) Rien | 4) Mauvais type,1,Fondamentaux Web,Expert,"L'opérateur `=` est une affectation. L'expression affecte la chaîne 'admin' à `$user` et est ensuite évaluée à `TRUE`, rendant la condition toujours vraie. L'opérateur de comparaison est `==` ou `===`."
"Quel problème de standards Drupal voyez-vous ici ? <code>function example_menu() { return TRUE; }</code>",1) Hook obsolète | 2) Mauvais nommage | 3) Manque de PHPDoc | 4) Rien,1,Drupal Core API,Expert,"Le hook `hook_menu()` est un hook de Drupal 7. Il est obsolète dans les versions modernes de Drupal et a été remplacé par les fichiers de définition de routes (`*.routing.yml`) et de liens de menu (`*.links.menu.yml`)."
"Comment valider un champ personnalisé dans une entité ?","1) Constraint Validator | 2) hook_entity_validate | 3) hook_form_alter | 4) Validation API","1,2",Drupal Core API,Expert,"La méthode moderne et réutilisable est de créer un plugin de contrainte (Constraint) et son validateur (Constraint Validator) via l'API de Validation (1). On peut également utiliser `hook_entity_validate()` (2) pour des validations plus globales au niveau de l'entité."
"Quelle faille est présente dans ce code Twig ? <code>{{ input }}</code>",1) XSS | 2) CSRF | 3) Injection SQL | 4) Rien,4,Sécurité,Expert,"Aucune. Twig est configuré par défaut dans Drupal pour échapper automatiquement toute sortie. Ce code est sécurisé contre les attaques XSS. Il deviendrait vulnérable uniquement si le filtre `|raw` était utilisé."
"Quel problème de standards Drupal voyez-vous ici ? <code>/** Affiche */ function hello($name) { echo $name; }</code>",1) Manque @param | 2) Manque @return | 3) Mauvais type | 4) Rien,"1,2",Communauté,Expert,"Le PHPDoc est incomplet. Il doit documenter chaque paramètre avec `@param` (1) et le type de retour avec `@return` (2). Ici, il manque `@param string $name` et `@return void`."
"Comment ajouter un lien de menu custom dans un module ?",1) Créer un fichier .links.menu.yml | 2) Ajouter dans .routing.yml | 3) Utiliser hook_menu | 4) Modifier .info.yml,1,Drupal Core API,Expert,"Les liens de menu sont définis de manière déclarative dans un fichier YAML nommé `[nom_du_module].links.menu.yml`. Ce fichier définit le titre du lien, sa route, son menu parent, etc."
"Quel problème de sécurité voyez-vous dans ce code ? <code>if (\$_POST['admin']) { do_admin(); } ?></code>",1) XSS | 2) CSRF | 3) Accès non contrôlé | 4) Injection SQL,"2,3",Sécurité,Expert,"(3) Accès non contrôlé : le code ne vérifie pas l'identité ou les droits de l'utilisateur, il se fie à une donnée POST. (2) CSRF : un attaquant peut forger une requête qui sera exécutée par le navigateur d'un administrateur authentifié à son insu si le formulaire n'est pas protégé par un token."
"Comment ajouter une validation personnalisée à un formulaire via Form API ?","1) #validate | 2) hook_form_FORM_ID_validate | 3) #custom_validate | 4) hook_form_alter","1,2",Drupal Core API,Expert,"On peut ajouter une ou plusieurs fonctions de validation à la clé `#validate` (1) du tableau de formulaire. Alternativement, on peut utiliser `hook_form_FORM_ID_validate()` (2) pour attacher une validation spécifique à un ID de formulaire, ce qui est une pratique courante."
"Quelles méthodes permettent de modifier dynamiquement un render array dans un module ?",1) hook_preprocess_HOOK | 2) hook_form_alter | 3) hook_page_alter | 4) hook_node_view,1,Drupal Core API,Moyen,"Les hooks de pré-processus (`hook_preprocess_HOOK`) sont spécifiquement conçus pour intercepter un 'render array' juste avant son rendu, afin d'y ajouter ou modifier des variables qui seront disponibles dans le template Twig correspondant."
"Quelles méthodes permettent de modifier dynamiquement le menu principal dans Drupal ?",1) hook_menu_alter | 2) hook_preprocess_menu | 3) hook_page_build | 4) MenuLinkTreeManipulatorInterface,"1,4",Drupal Core API,Moyen,"Les définitions de liens de menu peuvent être altérées avec `hook_menu_links_discovered_alter` ou `hook_menu_alter` (1). Pour manipuler l'arbre de menu rendu (réordonner, etc.), on utilise un service qui implémente `MenuLinkTreeManipulatorInterface` (4)."
"Quelles sont les étapes pour créer un type d’entité personnalisé ?","1) Définir la classe de l’entité | 2) Déclarer les champs de base | 3) Déclarer le schéma dans hook_schema | 4) Créer un fichier de configuration YAML","1,4",Drupal Core API,Moyen,"La création d'une entité de contenu personnalisée commence par une classe d'entité (1) annotée, qui définit ses propriétés. La définition des champs de base, des handlers et d'autres métadonnées se fait directement dans l'annotation de la classe, qui est une forme de configuration YAML interprétée (4)."
"Quelles méthodes permettent d’intégrer un fichier JavaScript à une page spécifique dans Drupal ?","1) hook_page_attachments_alter | 2) hook_preprocess_page | 3) .libraries.yml | 4) inline dans le template Twig","1,2",Thème,Moyen,"Pour attacher une bibliothèque à une page de manière conditionnelle, on peut utiliser `hook_page_attachments_alter` (1) ou `hook_preprocess_page` (2) et y ajouter la bibliothèque à l'élément `#attached`."
"Quelles sont les étapes pour créer un test fonctionnel automatisé dans Drupal ?","1) Étendre BrowserTestBase | 2) Utiliser Simpletest | 3) Activer les modules nécessaires | 4) Définir le scénario de test","1,3,4",Fondamentaux Web,Moyen,"Un test fonctionnel moderne étend la classe `BrowserTestBase` (1). On doit spécifier les modules à activer pour le test (3). Le corps du test contient le scénario à exécuter, avec des assertions pour vérifier les résultats (4). Simpletest (2) est l'ancien framework, obsolète."
"Quelles sont les bonnes pratiques pour protéger un endpoint REST custom dans Drupal ?","1) Utiliser l’authentification appropriée (ex: OAuth, JWT) | 2) Valider les tokens CSRF | 3) Restreindre l’accès par permission | 4) Désactiver le cache","1,3",Sécurité,Moyen,"La sécurité d'un endpoint REST repose sur une méthode d'authentification robuste (1) (les tokens étant préférables aux cookies pour des API) et une vérification fine des permissions de l'utilisateur authentifié (3)."
"Quelles sont les étapes pour créer un plugin Block custom ?","1) Définir la classe du plugin | 2) Créer une annotation | 3) Implémenter la méthode build() | 4) Ajouter dans .libraries.yml","1,2,3",Drupal Core API,Moyen,"Pour créer un bloc, il faut : (1) créer une classe PHP qui étend `BlockBase`, (2) ajouter une annotation `@Block` au-dessus de la classe, et (3) implémenter la méthode `build()` qui retourne le contenu du bloc sous forme de 'render array'."
"Quelles méthodes permettent de restreindre l’accès à une route custom dans Drupal ?",1) Définir _permission dans routing.yml | 2) Utiliser un AccessCheck | 3) Utiliser des conditions dans le contrôleur | 4) Définir _access_check dans routing.yml,"1,2,4",Sécurité,Moyen,"Dans le fichier `*.routing.yml`, on peut utiliser `_permission` (1) pour un contrôle simple. Pour une logique complexe, on crée un service de vérification d'accès et on le référence via `_custom_access`. Le système de Drupal transforme `_custom_access: 'TRUE'` en `_access_check: 'TRUE'` (4) implicitement."
"En POO PHP, vous avez une classe `final class ReportGenerator`. Une autre classe `CustomReport` tente d'en hériter via `class CustomReport extends ReportGenerator`. Quelle erreur PHP sera générée ?","1) Fatal error: Class ReportGenerator contains abstract methods... | 2) Fatal error: Class CustomReport may not inherit from final class (ReportGenerator) | 3) Parse error: syntax error, unexpected 'extends' | 4) Notice: Class ReportGenerator is final and should not be extended.",2,"1.2 OO PHP programming concepts",Difficile,"Le mot-clé `final` devant une déclaration de classe empêche explicitement toute autre classe d'en hériter. C'est une décision d'architecture pour garantir que le comportement de la classe ne puisse pas être modifié par héritage. Tenter de le faire résulte en une erreur fatale."
"Quelle commande Composer permet d'examiner pourquoi une version spécifique d'un package (par ex: `drupal/core-dev 10.1.5`) est installée et quels autres packages en dépendent ?",1) composer show drupal/core-dev | 2) composer depends drupal/core-dev | 3) composer why drupal/core-dev | 4) composer prohibits drupal/core-dev,3,"1.3 Managing dependencies using Composer",Difficile,"La commande `composer why` (ou `composer depends` qui est un alias) est l'outil de diagnostic qui parcourt l'arbre des dépendances pour expliquer pourquoi un package donné est présent dans votre projet. `prohibits` fait l'inverse (explique pourquoi un package ne peut pas être installé), et `show` affiche des informations sur le package sans expliquer la chaîne de dépendance."
"Vous devez créer une route qui n'est accessible que si un module spécifique, disons `my_feature`, est activé. Quelle est la bonne syntaxe à utiliser dans votre fichier `mon_module.routing.yml` ?",1) `requirements: _module_exists: 'my_feature'` | 2) `requirements: _module: 'my_feature'` | 3) `requirements: _custom_access: '\Drupal\my_module\Access\MyFeatureAccessCheck'` | 4) `options: _module_dependency: 'my_feature'`,1,"2.1 Routing system and Menu API",Difficile,"Le système de routage de Drupal fournit un vérificateur d'accès prêt à l'emploi, `_module_exists`, qui permet de conditionner l'accès à une route à l'activation d'un ou plusieurs modules. C'est la méthode la plus simple et la plus déclarative pour ce besoin. Créer une classe d'accès personnalisée (Option 3) serait excessif pour ce cas simple."
"Dans un `hook_form_alter`, vous voulez ajouter une fonction de validation qui s'exécute *avant* toutes les autres validations de base du formulaire. Comment devez-vous l'ajouter ?","1) `$form['#validate'][] = 'my_custom_validation';` | 2) `array_unshift($form['#validate'], 'my_custom_validation');` | 3) `$form['#after_build'][] = 'my_custom_validation';` | 4) `$form['#validate_early'][] = 'my_custom_validation';`",2,"2.2 Build, alter, validate and submit forms using Form API",Expert,"Les validateurs de formulaire sont exécutés dans l'ordre où ils apparaissent dans le tableau `$form['#validate']`. Pour qu'une validation s'exécute en premier, il faut l'ajouter au début du tableau en utilisant `array_unshift()`. L'ajout simple avec `[]` (Option 1) la placerait à la fin. `#after_build` est pour la modification du rendu, pas la validation."
"Vous créez un champ calculé qui dépend de la valeur d'un autre champ sur la même entité. Comment forcer le recalcul de votre champ lorsque le champ source est modifié ?",1) En implémentant `hook_entity_presave` et en appelant `$entity->get('mon_champ_calcule')->recompute()` | 2) La dépendance est automatique si les deux champs sont sur la même entité. | 3) En utilisant la méthode `setValue()` sur le champ calculé dans un `hook_entity_update`. | 4) En déclarant la dépendance dans l'annotation `@FieldType` du champ calculé.,1,"2.3 Interact with the entity system using Entity API",Expert,"Le recalcul des champs calculés n'est pas automatique lors de la mise à jour d'une entité. Le moment approprié pour déclencher ce recalcul est juste avant la sauvegarde, via `hook_entity_presave`. Dans ce hook, on peut vérifier si le champ source a changé et, si c'est le cas, forcer le recalcul. La méthode `recompute()` n'existe pas, mais on peut simplement effacer la valeur existante (`$entity->get('mon_champ_calcule')->setValue(NULL)`) pour que la méthode `computeValue()` soit appelée à nouveau."
"Un collègue se plaint que son `hook_node_view_alter` ne semble pas fonctionner. Le cache a été vidé. Quel outil de débogage et quelle méthode utiliseriez-vous pour vérifier si Drupal découvre même son implémentation de hook ?",1) Activer le module Devel et vérifier la page `/devel/hooks`. | 2) Placer un point d'arrêt Xdebug dans `ModuleHandler::invokeAll()` et inspecter la variable `$implementations`. | 3) Utiliser Drush : `drush ev """"print_r(\Drupal::moduleHandler()->getImplementations('node_view_alter'));""""` | 4) Toutes ces réponses sont des méthodes valides pour diagnostiquer le problème.,4,"3.1 Debug code",Difficile,"Les trois méthodes sont des approches valides et professionnelles pour ce problème. L'option 1 (Devel) est une approche visuelle rapide. L'option 2 (Xdebug) est la plus puissante pour une analyse en temps réel de l'exécution du code. L'option 3 (Drush) est idéale pour une vérification rapide en ligne de commande sans interface graphique."
"Dans un template Twig, vous avez une variable `complex_array`. Quelle syntaxe permet d'afficher son contenu de manière détaillée pour le débogage, à condition que le module Devel et l'intégration Kint soient activés ?",1) `{{ dump(complex_array) }}` | 2) `{% debug complex_array %}` | 3) `{{ kint(complex_array) }}` | 4) `{{ devel_dump(complex_array) }}`,3,"4.2 Work with Twig templates and syntax",Difficile,"Lorsque le module Devel est configuré pour utiliser Kint, il expose une fonction Twig `kint()`. C'est la méthode recommandée pour obtenir un affichage riche et interactif des variables. `dump()` est une fonction de base de Twig, moins détaillée. Les autres options n'existent pas par défaut."
"Un bloc personnalisé affichant une information qui dépend du rôle de l'utilisateur est mis en cache de manière incorrecte. Le code est `return ['#markup' => $output, '#cache' => ['tags' => ['user:' . $user->id()]]];`. Qu'est-ce qui manque pour assurer une variation correcte du cache ?",1) `'max-age' => 0` | 2) `'contexts' => ['user.roles']` | 3) `'contexts' => ['url.path']` | 4) Une invalidation de tag personnalisée.,2,"5.3 Implement Drupal caching strategies using Cache API",Expert,"Les `tags` servent à l'invalidation (QUAND vider le cache), tandis que les `contexts` servent à la variation (POUR QUOI créer une version différente du cache). Ici, le contenu varie en fonction des rôles de l'utilisateur. Le contexte de cache correct est donc `user.roles`. L'utilisation du tag `user:UID` invalidera le cache si l'utilisateur est modifié, mais ne créera pas de versions différentes pour un admin et un utilisateur anonyme."
"Votre module expose un endpoint REST qui renvoie des données sensibles. Quelle est la meilleure façon de restreindre l'accès à ce endpoint uniquement aux utilisateurs ayant la permission `access sensitive data` ?","1) Dans le contrôleur, vérifier avec `\Drupal::currentUser()->hasPermission('access sensitive data');` | 2) Dans `mon_module.routing.yml`, ajouter `requirements: _access: 'TRUE'` | 3) Dans `mon_module.routing.yml`, ajouter `requirements: _permission: 'access sensitive data'` | 4) Dans `mon_module.permissions.yml`, lier la permission à la route.",3,"6.3 Implement Drupal core security mechanisms",Difficile,"La méthode standard, la plus propre et la plus performante, consiste à définir la permission requise directement au niveau de la route dans le fichier `*.routing.yml`. Le système de routage de Drupal se chargera de vérifier la permission avant même que le code du contrôleur ne soit exécuté. Placer la vérification dans le contrôleur (Option 1) fonctionne mais est moins efficace et mélange la logique de routage avec la logique métier."
"Quel est le problème de sécurité principal dans le code de ce contrôleur de formulaire ?
<code>
public function submitForm(array &$form, FormStateInterface $form_state) {
  $url = $form_state->getValue('redirect_url');
  $response = new RedirectResponse($url);
  $response->send();
}
</code>",1) Injection de dépendances incorrecte. | 2) Risque de redirection ouverte (Open Redirect). | 3) Absence de protection CSRF. | 4) Mauvaise utilisation du service `messenger`. ,2,"6.2 Analyze and resolve security issues arising from custom code",Expert,"Ce code est vulnérable à une 'Open Redirect'. Il récupère une URL depuis les données du formulaire et redirige l'utilisateur sans aucune validation. Un attaquant pourrait créer un lien vers ce formulaire en passant une URL malveillante dans le champ `redirect_url`, faisant croire à l'utilisateur qu'il est sur un site de confiance alors qu'il est redirigé vers un site de phishing. La solution est de valider l'URL avec `UrlHelper::isExternal()` ou de s'assurer qu'elle est interne au site."
"Vous écrivez un patch pour un module contribué. Selon les standards de codage Drupal, comment devrait être formatée la ligne suivante ?
<code>`if($items>0){`</code>",1) <code>`if ( $items > 0 ) {`</code> | 2) <code>`if ($items > 0) {`</code> | 3) <code>`if($items > 0){`</code> | 4) <code>`if ($items>0) {`</code>,2,"7.2 Write code using Drupal coding standards",Facile,"Les standards de codage de Drupal sont très stricts sur l'espacement pour la lisibilité. La règle pour les structures de contrôle (`if`, `foreach`, etc.) est : un espace après le mot-clé (`if`), aucun espace après la parenthèse ouvrante, aucun espace avant la parenthèse fermante, et un espace avant l'accolade ouvrante."
"Vous créez un plugin de type `MyCustomPlugin`. Ce plugin a besoin d'accéder au service `current_user`. Quelle est l'implémentation correcte pour injecter ce service en respectant les standards de Drupal 11 ?","1) <code>class MyPlugin extends MyPluginBase { public function __construct(...) { parent::__construct(...); $this->currentUser = \Drupal::service('current_user'); } }</code> | 2) <code>class MyPlugin extends MyPluginBase implements ContainerFactoryPluginInterface { public function __construct(..., protected AccountInterface $currentUser) { ... } public static function create(ContainerInterface $container, ...) { return new static(..., $container->get('current_user')); } }</code> | 3) <code>class MyPlugin extends MyPluginBase { public function build() { $user = \Drupal::currentUser(); } }</code> | 4) <code>class MyPlugin extends MyPluginBase { protected $currentUser; public function __construct() { $this->currentUser = \Drupal::service('current_user'); } }</code>"",2,"2.4 Core APIs",Difficile,"La méthode correcte pour les plugins est d'implémenter `ContainerFactoryPluginInterface`. Cela oblige à créer une méthode `create()` statique qui reçoit le conteneur de services. C'est cette méthode qui est responsable de récupérer les services requis et de les passer au constructeur. Cette approche garantit que le plugin est correctement instancié par Drupal avec ses dépendances, le rendant découplé et testable."